# Lesson 4: Interfaces

## Theory

### 1. Interface Basics - Duck Typing
Interfaces in Go define behavior, not data. If it walks like a duck and quacks like a duck, it's a duck.

```go
// Interface definition
type Writer interface {
    Write([]byte) (int, error)
}

type Reader interface {
    Read([]byte) (int, error)
}

// Any type that implements these methods satisfies the interface
type FileHandler struct {
    filename string
}

func (f *FileHandler) Write(data []byte) (int, error) {
    // Implementation
    fmt.Printf("Writing %d bytes to %s\n", len(data), f.filename)
    return len(data), nil
}

func (f *FileHandler) Read(data []byte) (int, error) {
    // Implementation
    fmt.Printf("Reading from %s\n", f.filename)
    return 0, nil
}

// Usage - implicit implementation
func ProcessData(w Writer, data []byte) error {
    _, err := w.Write(data)
    return err
}

file := &FileHandler{filename: "test.txt"}
ProcessData(file, []byte("hello world")) // Works automatically!
```

**vs TypeScript/Node.js:**
```typescript
// TypeScript requires explicit implementation
interface Writer {
    write(data: Buffer): Promise<number>;
}

class FileHandler implements Writer { // explicit "implements"
    async write(data: Buffer): Promise<number> {
        // Implementation
        return data.length;
    }
}
```

### 2. Empty Interface and Type Assertions
The empty interface `interface{}` can hold any type (like `any` in TypeScript).

```go
// Empty interface accepts anything
func PrintAnything(value interface{}) {
    fmt.Printf("Value: %v, Type: %T\n", value, value)
}

// Type assertions to get back concrete types
func ProcessValue(value interface{}) {
    // Type assertion with ok pattern (safe)
    if str, ok := value.(string); ok {
        fmt.Printf("String: %s (length: %d)\n", str, len(str))
        return
    }

    if num, ok := value.(int); ok {
        fmt.Printf("Integer: %d (doubled: %d)\n", num, num*2)
        return
    }

    fmt.Println("Unknown type")
}

// Type switch for multiple types
func HandleValue(value interface{}) {
    switch v := value.(type) {
    case string:
        fmt.Printf("String: %s\n", v)
    case int:
        fmt.Printf("Integer: %d\n", v)
    case []int:
        fmt.Printf("Slice of ints: %v\n", v)
    case bool:
        fmt.Printf("Boolean: %t\n", v)
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}

// Usage
PrintAnything("hello")
PrintAnything(42)
PrintAnything([]string{"a", "b"})

ProcessValue("Go is awesome")
ProcessValue(100)

HandleValue(true)
HandleValue([]int{1, 2, 3})
```

### 3. Interface Composition
Interfaces can be composed from other interfaces.

```go
// Base interfaces
type Reader interface {
    Read([]byte) (int, error)
}

type Writer interface {
    Write([]byte) (int, error)
}

type Closer interface {
    Close() error
}

// Composed interfaces
type ReadWriter interface {
    Reader
    Writer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}

// Real-world example: Database operations
type UserReader interface {
    GetUser(id int) (*User, error)
    ListUsers() ([]*User, error)
}

type UserWriter interface {
    CreateUser(user *User) error
    UpdateUser(user *User) error
    DeleteUser(id int) error
}

type UserRepository interface {
    UserReader
    UserWriter
    Close() error
}

// Implementation
type PostgresUserRepo struct {
    db *sql.DB
}

func (r *PostgresUserRepo) GetUser(id int) (*User, error) {
    // Implementation
    return &User{ID: id}, nil
}

func (r *PostgresUserRepo) CreateUser(user *User) error {
    // Implementation
    return nil
}

// ... other methods

func (r *PostgresUserRepo) Close() error {
    return r.db.Close()
}
```

### 4. Dependency Injection Pattern
Interfaces enable clean dependency injection and testability.

```go
// Service layer depends on interfaces, not concrete types
type EmailSender interface {
    SendEmail(to, subject, body string) error
}

type UserRepository interface {
    GetUser(id int) (*User, error)
    SaveUser(user *User) error
}

type UserService struct {
    userRepo    UserRepository
    emailSender EmailSender
}

func NewUserService(repo UserRepository, sender EmailSender) *UserService {
    return &UserService{
        userRepo:    repo,
        emailSender: sender,
    }
}

func (s *UserService) RegisterUser(email, name string) error {
    user := &User{
        Email: email,
        Name:  name,
        IsActive: true,
    }

    if err := s.userRepo.SaveUser(user); err != nil {
        return fmt.Errorf("failed to save user: %w", err)
    }

    if err := s.emailSender.SendEmail(email, "Welcome!", "Thanks for joining!"); err != nil {
        return fmt.Errorf("failed to send welcome email: %w", err)
    }

    return nil
}

// Production implementations
type SMTPEmailSender struct {
    host string
    port int
}

func (s *SMTPEmailSender) SendEmail(to, subject, body string) error {
    // Real SMTP implementation
    fmt.Printf("Sending email to %s: %s\n", to, subject)
    return nil
}

type PostgresUserRepository struct {
    db *sql.DB
}

func (r *PostgresUserRepository) GetUser(id int) (*User, error) {
    // Real database query
    return &User{}, nil
}

func (r *PostgresUserRepository) SaveUser(user *User) error {
    // Real database insert
    return nil
}

// Test implementations (mocks)
type MockEmailSender struct {
    SentEmails []string
}

func (m *MockEmailSender) SendEmail(to, subject, body string) error {
    m.SentEmails = append(m.SentEmails, to)
    return nil
}

// Usage
func main() {
    // Production
    emailSender := &SMTPEmailSender{host: "smtp.gmail.com", port: 587}
    userRepo := &PostgresUserRepository{db: db}
    userService := NewUserService(userRepo, emailSender)

    // Testing
    mockEmail := &MockEmailSender{}
    mockRepo := &MockUserRepository{}
    testService := NewUserService(mockRepo, mockEmail)
}
```

### 5. Error Interface and Custom Errors
The `error` type is actually an interface in Go.

```go
// The built-in error interface
type error interface {
    Error() string
}

// Custom error types
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error in field '%s': %s", e.Field, e.Message)
}

type NotFoundError struct {
    Resource string
    ID       interface{}
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s with ID %v not found", e.Resource, e.ID)
}

// Error wrapping (Go 1.13+)
type ServiceError struct {
    Operation string
    Err       error
}

func (e *ServiceError) Error() string {
    return fmt.Sprintf("service error in %s: %v", e.Operation, e.Err)
}

func (e *ServiceError) Unwrap() error {
    return e.Err
}

// Usage in service
func (s *UserService) GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, &ValidationError{
            Field:   "id",
            Message: "must be positive",
        }
    }

    user, err := s.userRepo.GetUser(id)
    if err != nil {
        return nil, &ServiceError{
            Operation: "GetUser",
            Err:       err,
        }
    }

    if user == nil {
        return nil, &NotFoundError{
            Resource: "User",
            ID:       id,
        }
    }

    return user, nil
}

// Error handling with type assertions
func HandleUserError(err error) {
    switch e := err.(type) {
    case *ValidationError:
        fmt.Printf("Validation failed: %s\n", e.Message)
    case *NotFoundError:
        fmt.Printf("Resource not found: %s\n", e.Error())
    case *ServiceError:
        fmt.Printf("Service error: %s\n", e.Operation)
        // Can unwrap to get original error
        if originalErr := errors.Unwrap(e); originalErr != nil {
            fmt.Printf("Original error: %v\n", originalErr)
        }
    default:
        fmt.Printf("Unknown error: %v\n", err)
    }
}
```

### 6. Real-world Pattern: Repository and Service Layers
```go
// Domain models
type User struct {
    ID       int       `json:"id"`
    Email    string    `json:"email"`
    Name     string    `json:"name"`
    IsActive bool      `json:"is_active"`
    CreatedAt time.Time `json:"created_at"`
}

type Product struct {
    ID          int     `json:"id"`
    Name        string  `json:"name"`
    Price       float64 `json:"price"`
    CategoryID  int     `json:"category_id"`
}

// Repository interfaces (data layer)
type UserRepository interface {
    GetByID(id int) (*User, error)
    GetByEmail(email string) (*User, error)
    Create(user *User) error
    Update(user *User) error
    Delete(id int) error
    List(limit, offset int) ([]*User, error)
}

type ProductRepository interface {
    GetByID(id int) (*Product, error)
    GetByCategory(categoryID int) ([]*Product, error)
    Create(product *Product) error
    Update(product *Product) error
    Delete(id int) error
}

// Service interfaces (business logic layer)
type UserService interface {
    RegisterUser(email, name string) (*User, error)
    AuthenticateUser(email, password string) (*User, error)
    UpdateProfile(userID int, name string) error
    DeactivateUser(userID int) error
    GetUserProfile(userID int) (*User, error)
}

type ProductService interface {
    CreateProduct(name string, price float64, categoryID int) (*Product, error)
    UpdateProductPrice(productID int, newPrice float64) error
    GetProductsByCategory(categoryID int) ([]*Product, error)
    DeleteProduct(productID int) error
}

// Implementation
type userService struct {
    userRepo UserRepository
    logger   Logger
}

func NewUserService(repo UserRepository, logger Logger) UserService {
    return &userService{
        userRepo: repo,
        logger:   logger,
    }
}

func (s *userService) RegisterUser(email, name string) (*User, error) {
    // Validation
    if email == "" || !strings.Contains(email, "@") {
        return nil, &ValidationError{Field: "email", Message: "invalid email format"}
    }

    // Check if user exists
    existingUser, err := s.userRepo.GetByEmail(email)
    if err != nil && !errors.Is(err, &NotFoundError{}) {
        return nil, fmt.Errorf("failed to check existing user: %w", err)
    }

    if existingUser != nil {
        return nil, &ValidationError{Field: "email", Message: "email already exists"}
    }

    // Create new user
    user := &User{
        Email:     email,
        Name:      name,
        IsActive:  true,
        CreatedAt: time.Now(),
    }

    if err := s.userRepo.Create(user); err != nil {
        s.logger.Error("Failed to create user", "email", email, "error", err)
        return nil, fmt.Errorf("failed to create user: %w", err)
    }

    s.logger.Info("User registered successfully", "email", email, "userID", user.ID)
    return user, nil
}
```

---

## Practice Questions

**Note**: B¡n s½ làm bài t­p trong th° måc `homework/` sau này nhé!

### Basic Level

**1. Shape Interface**
Create a `Shape` interface with methods `Area()` and `Perimeter()`. Implement it for `Rectangle`, `Circle`, and `Triangle` structs. Create a function that calculates total area of multiple shapes.

**2. Animal Behavior**
Create interfaces `Speaker` and `Mover` with methods `Speak()` and `Move()`. Create `Dog`, `Cat`, and `Bird` structs that implement these interfaces differently.

### Intermediate Level

**3. Payment System**
Design a payment processing system:
```go
type PaymentMethod interface {
    ProcessPayment(amount float64) error
    GetFee(amount float64) float64
}

type PaymentProcessor interface {
    AddMethod(method PaymentMethod)
    ProcessPayment(methodType string, amount float64) error
}
```
Implement `CreditCard`, `PayPal`, and `BankTransfer` payment methods.

**4. Notification System**
Create a notification system with multiple channels:
```go
type NotificationSender interface {
    SendNotification(message string, recipient string) error
    SupportsRecipientType(recipientType string) bool
}

type NotificationService interface {
    AddSender(name string, sender NotificationSender)
    SendNotification(channels []string, message string, recipient string) error
}
```
Implement `EmailSender`, `SMSSender`, and `PushNotificationSender`.

### Advanced Level

**5. Generic Repository Pattern**
Create a generic repository pattern using interfaces:
```go
type Entity interface {
    GetID() int
    SetID(id int)
}

type Repository[T Entity] interface {
    Create(entity T) error
    GetByID(id int) (T, error)
    Update(entity T) error
    Delete(id int) error
    List(filters map[string]interface{}) ([]T, error)
}

type UnitOfWork interface {
    BeginTransaction() error
    Commit() error
    Rollback() error
    UserRepository() Repository[*User]
    ProductRepository() Repository[*Product]
}
```

**6. Event-Driven Architecture**
Design an event system with interfaces:
```go
type Event interface {
    GetType() string
    GetData() interface{}
    GetTimestamp() time.Time
}

type EventHandler interface {
    Handle(event Event) error
    CanHandle(eventType string) bool
}

type EventBus interface {
    Subscribe(eventType string, handler EventHandler)
    Publish(event Event) error
    PublishAsync(event Event)
}

type EventStore interface {
    SaveEvent(event Event) error
    GetEvents(eventType string, from, to time.Time) ([]Event, error)
}
```

**7. Microservice Communication**
Create interfaces for service-to-service communication:
```go
type ServiceClient interface {
    Call(serviceName, method string, request interface{}) (interface{}, error)
    CallAsync(serviceName, method string, request interface{}) <-chan Result
}

type ServiceRegistry interface {
    RegisterService(serviceName, address string) error
    DiscoverService(serviceName string) ([]string, error)
    HealthCheck(serviceName string) error
}

type LoadBalancer interface {
    SelectEndpoint(serviceName string) (string, error)
    UpdateEndpoints(serviceName string, endpoints []string)
}
```

**8. Clean Architecture with DDD**
Implement Clean Architecture interfaces:
```go
// Domain layer
type UserDomainService interface {
    ValidateUserRegistration(user *User) error
    CanUserPerformAction(userID int, action string) (bool, error)
}

// Application layer
type UserUseCase interface {
    RegisterUser(cmd RegisterUserCommand) (*User, error)
    UpdateUserProfile(cmd UpdateProfileCommand) error
    DeactivateUser(cmd DeactivateUserCommand) error
}

// Infrastructure layer
type EmailService interface {
    SendWelcomeEmail(user *User) error
    SendPasswordResetEmail(user *User, token string) error
}

type CacheService interface {
    Set(key string, value interface{}, ttl time.Duration) error
    Get(key string, dest interface{}) error
    Delete(key string) error
}

// Commands and queries (CQRS pattern)
type Command interface {
    Validate() error
}

type Query interface {
    Validate() error
}

type CommandHandler[T Command] interface {
    Handle(cmd T) error
}

type QueryHandler[T Query, R any] interface {
    Handle(query T) (R, error)
}
```

---

**Expected Completion Time**: 4-5 hours for thorough understanding and practice

**Next Lesson Preview**: Goroutines and Channels - Go's powerful concurrency model for building scalable applications.