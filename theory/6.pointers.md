# Lesson 6: Pointers and Memory Management

## Theory

### 1. Pointers Basics - Memory Addresses
Pointers in Go are explicit, unlike references in Node.js/TypeScript which are hidden.

```go
import (
    "fmt"
    "unsafe"
)

func pointerBasics() {
    // Basic pointer operations
    x := 42
    p := &x    // p is a pointer to x (address of x)

    fmt.Printf("x = %d\n", x)           // x = 42
    fmt.Printf("&x = %p\n", &x)         // &x = 0xc000014098 (address)
    fmt.Printf("p = %p\n", p)           // p = 0xc000014098 (same address)
    fmt.Printf("*p = %d\n", *p)         // *p = 42 (value at address)

    *p = 21    // Change value through pointer
    fmt.Printf("x = %d\n", x)           // x = 21 (x changed!)

    // Zero value of pointer is nil
    var ptr *int
    fmt.Printf("ptr = %v\n", ptr)       // ptr = <nil>

    if ptr == nil {
        fmt.Println("Pointer is nil")
    }
}

// Pointer types
func pointerTypes() {
    var intPtr *int
    var stringPtr *string
    var structPtr *User
    var slicePtr *[]int
    var mapPtr *map[string]int

    fmt.Printf("*int: %T\n", intPtr)        // *int
    fmt.Printf("*string: %T\n", stringPtr)  // *string
    fmt.Printf("*User: %T\n", structPtr)    // *User
    fmt.Printf("*[]int: %T\n", slicePtr)    // *[]int
    fmt.Printf("*map[string]int: %T\n", mapPtr) // *map[string]int
}
```

**vs TypeScript/Node.js:**
```typescript
// TypeScript - references are implicit
let x = 42;
let obj = { value: 42 };

function modifyValue(val: number) {
    val = 21; // Doesn't change original x
}

function modifyObject(o: { value: number }) {
    o.value = 21; // Changes original obj.value
}

modifyValue(x);      // x still 42
modifyObject(obj);   // obj.value now 21
```

```go
// Go - pointers are explicit
func modifyValue(val int) {
    val = 21 // Doesn't change original
}

func modifyValueWithPointer(val *int) {
    *val = 21 // Changes original
}

x := 42
modifyValue(x)              // x still 42
modifyValueWithPointer(&x)  // x now 21
```

### 2. Pointers with Structs
Pointers are commonly used with structs for efficiency and modification.

```go
type User struct {
    ID    int
    Name  string
    Email string
}

func structPointers() {
    // Creating structs
    user1 := User{ID: 1, Name: "John", Email: "john@example.com"}
    user2 := &User{ID: 2, Name: "Jane", Email: "jane@example.com"}
    user3 := new(User) // Creates zero-value struct and returns pointer

    fmt.Printf("user1 type: %T\n", user1)  // User
    fmt.Printf("user2 type: %T\n", user2)  // *User
    fmt.Printf("user3 type: %T\n", user3)  // *User

    // Accessing fields through pointer (automatic dereferencing)
    fmt.Printf("user2.Name: %s\n", user2.Name)     // Go automatically dereferences
    fmt.Printf("(*user2).Name: %s\n", (*user2).Name) // Explicit dereferencing

    // Modifying through pointer
    user2.Name = "Jane Doe"
    fmt.Printf("Modified: %s\n", user2.Name)
}

// Function with struct pointer receiver (from previous lessons)
func (u *User) UpdateEmail(newEmail string) {
    u.Email = newEmail // Automatically dereferenced
}

// Comparing value vs pointer receivers
func (u User) GetDisplayName() string {
    return fmt.Sprintf("%s (%d)", u.Name, u.ID)
}

func (u *User) GetDisplayNamePtr() string {
    return fmt.Sprintf("%s (%d)", u.Name, u.ID)
}

func receiverComparison() {
    user := User{ID: 1, Name: "Alice"}
    userPtr := &User{ID: 2, Name: "Bob"}

    // Both work with value receiver
    fmt.Println(user.GetDisplayName())    // Alice (1)
    fmt.Println(userPtr.GetDisplayName()) // Bob (2) - Go auto-dereferences

    // Both work with pointer receiver
    fmt.Println(user.GetDisplayNamePtr())    // Alice (1) - Go auto-references
    fmt.Println(userPtr.GetDisplayNamePtr()) // Bob (2)
}
```

### 3. Memory Allocation - Stack vs Heap
Understanding where Go allocates memory is crucial for performance.

```go
import (
    "runtime"
    "fmt"
)

// Stack allocation (fast, automatic cleanup)
func stackAllocation() *int {
    x := 42 // This might be allocated on stack or heap
    return &x // Returning address - Go moves to heap if needed
}

// Heap allocation (slower, garbage collected)
func heapAllocation() *User {
    user := &User{ID: 1, Name: "Alice"} // Allocated on heap
    return user
}

// Escape analysis example
func escapeAnalysis() {
    // Local variable - likely stack allocated
    localVar := 100
    fmt.Println(localVar)

    // Returned pointer - escapes to heap
    ptr := stackAllocation()
    fmt.Println(*ptr)

    // Large struct - likely heap allocated
    largeStruct := make([]int, 10000)
    fmt.Println(len(largeStruct))

    // Captured by closure - might escape to heap
    x := 42
    func() {
        fmt.Println(x) // x might escape to heap
    }()
}

// Check allocation with build flags
// go build -gcflags="-m" main.go
// Shows escape analysis decisions
```

### 4. Garbage Collector
Go has an automatic garbage collector that manages heap memory.

```go
import (
    "runtime"
    "runtime/debug"
    "time"
)

func gcExample() {
    // Get initial memory stats
    var m1, m2 runtime.MemStats
    runtime.ReadMemStats(&m1)

    fmt.Printf("Initial heap size: %d KB\n", m1.HeapAlloc/1024)

    // Allocate lots of memory
    data := make([]*User, 1000000)
    for i := 0; i < 1000000; i++ {
        data[i] = &User{
            ID:   i,
            Name: fmt.Sprintf("User%d", i),
        }
    }

    runtime.ReadMemStats(&m2)
    fmt.Printf("After allocation: %d KB\n", m2.HeapAlloc/1024)

    // Clear references (make eligible for GC)
    data = nil

    // Force garbage collection
    runtime.GC()

    var m3 runtime.MemStats
    runtime.ReadMemStats(&m3)
    fmt.Printf("After GC: %d KB\n", m3.HeapAlloc/1024)

    // GC stats
    fmt.Printf("Number of GC cycles: %d\n", m3.NumGC)
    fmt.Printf("Total GC pause time: %v\n", time.Duration(m3.PauseTotalNs))
}

// Control GC behavior
func gcControl() {
    // Set GC target percentage (default: 100)
    debug.SetGCPercent(50) // More frequent GC

    // Set memory limit (Go 1.19+)
    debug.SetMemoryLimit(100 << 20) // 100MB limit

    // Disable GC temporarily
    debug.SetGCPercent(-1)
    // ... do work that doesn't want GC interruption
    debug.SetGCPercent(100) // Re-enable
}
```

### 5. Memory Leaks and Prevention
Common memory leak patterns and how to avoid them.

```go
import (
    "context"
    "time"
)

// Memory leak: goroutine not terminating
func goroutineLeakBad() {
    ch := make(chan int)

    go func() {
        for {
            select {
            case <-ch:
                // Process data
            }
            // No way to exit! Goroutine leaks
        }
    }()

    // ch is never closed, goroutine runs forever
}

func goroutineLeakGood() {
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel() // Ensure cleanup

    ch := make(chan int)

    go func() {
        for {
            select {
            case <-ch:
                // Process data
            case <-ctx.Done():
                return // Proper cleanup
            }
        }
    }()

    // Cancel context when done
}

// Memory leak: slice holding references
func sliceLeakBad() []User {
    largeSlice := make([]User, 1000000)
    // Initialize slice...

    // Returning subslice still holds reference to entire backing array
    return largeSlice[0:10] // Leaks 999,990 elements!
}

func sliceLeakGood() []User {
    largeSlice := make([]User, 1000000)
    // Initialize slice...

    // Copy to new slice to release reference
    result := make([]User, 10)
    copy(result, largeSlice[0:10])
    return result // Original slice can be GC'd
}

// Memory leak: map not cleaned up
type Cache struct {
    data map[string]*CacheItem
}

type CacheItem struct {
    Value     interface{}
    ExpiresAt time.Time
}

func (c *Cache) CleanupExpired() {
    now := time.Now()
    for key, item := range c.data {
        if now.After(item.ExpiresAt) {
            delete(c.data, key) // Remove expired items
        }
    }
}

// Memory leak: circular references
type Node struct {
    Value    int
    Parent   *Node
    Children []*Node
}

func createTree() *Node {
    root := &Node{Value: 1}
    child := &Node{Value: 2, Parent: root}
    root.Children = append(root.Children, child)

    // Go's GC can handle this circular reference
    // But in some cases, you might want to break cycles manually
    return root
}

func breakCycles(node *Node) {
    for _, child := range node.Children {
        child.Parent = nil // Break parent reference
        breakCycles(child)
    }
    node.Children = nil
}
```

### 6. Performance Optimization
Memory-related performance optimizations.

```go
import (
    "sync"
)

// Object pooling to reduce allocations
var userPool = sync.Pool{
    New: func() interface{} {
        return &User{}
    },
}

func useObjectPool() *User {
    // Get from pool
    user := userPool.Get().(*User)

    // Reset fields
    user.ID = 0
    user.Name = ""
    user.Email = ""

    return user
}

func releaseToPool(user *User) {
    // Clear sensitive data
    user.Email = ""

    // Return to pool
    userPool.Put(user)
}

// Pre-allocate slices when size is known
func preAllocateSlices() {
    // Bad: causes multiple allocations
    var badSlice []int
    for i := 0; i < 1000; i++ {
        badSlice = append(badSlice, i) // Multiple reallocations
    }

    // Good: single allocation
    goodSlice := make([]int, 0, 1000) // Pre-allocate capacity
    for i := 0; i < 1000; i++ {
        goodSlice = append(goodSlice, i) // No reallocations
    }

    // Even better: if you know exact size
    bestSlice := make([]int, 1000) // Allocate exact size
    for i := 0; i < 1000; i++ {
        bestSlice[i] = i // Direct assignment
    }
}

// Struct field ordering for memory alignment
type BadStruct struct {
    a bool    // 1 byte
    b int64   // 8 bytes (7 bytes padding after a)
    c bool    // 1 byte
    d int64   // 8 bytes (7 bytes padding after c)
    // Total: 32 bytes (14 bytes wasted in padding)
}

type GoodStruct struct {
    b int64   // 8 bytes
    d int64   // 8 bytes
    a bool    // 1 byte
    c bool    // 1 byte
    // Total: 18 bytes (6 bytes padding at end for alignment)
}

func checkStructSizes() {
    fmt.Printf("BadStruct size: %d bytes\n", unsafe.Sizeof(BadStruct{}))   // 32
    fmt.Printf("GoodStruct size: %d bytes\n", unsafe.Sizeof(GoodStruct{})) // 18
}
```

### 7. Unsafe Package - Low-level Operations
The unsafe package provides low-level memory operations (use carefully!).

```go
import (
    "unsafe"
    "reflect"
)

func unsafeOperations() {
    // Get size and alignment
    var x int64
    fmt.Printf("Size of int64: %d bytes\n", unsafe.Sizeof(x))
    fmt.Printf("Alignment of int64: %d bytes\n", unsafe.Alignof(x))

    // Pointer arithmetic (dangerous!)
    arr := [3]int{1, 2, 3}
    ptr := unsafe.Pointer(&arr[0])

    // Get second element using pointer arithmetic
    secondPtr := unsafe.Pointer(uintptr(ptr) + unsafe.Sizeof(arr[0]))
    secondValue := *(*int)(secondPtr)
    fmt.Printf("Second element: %d\n", secondValue) // 2

    // Convert between pointer types
    var str string = "Hello"
    strHeader := (*reflect.StringHeader)(unsafe.Pointer(&str))
    fmt.Printf("String data pointer: %x\n", strHeader.Data)
    fmt.Printf("String length: %d\n", strHeader.Len)
}

// Zero-copy string to byte slice conversion (unsafe)
func stringToBytes(s string) []byte {
    return *(*[]byte)(unsafe.Pointer(
        &struct {
            string
            Cap int
        }{s, len(s)},
    ))
}

// Zero-copy byte slice to string conversion (unsafe)
func bytesToString(b []byte) string {
    return *(*string)(unsafe.Pointer(&b))
}

// WARNING: These unsafe operations can cause:
// - Segmentation faults
// - Data corruption
// - Security vulnerabilities
// Only use when absolutely necessary and you understand the risks!
```

### 8. Memory Profiling with pprof
Understanding and debugging memory usage.

```go
import (
    _ "net/http/pprof" // Import for side effects
    "net/http"
    "log"
    "runtime/pprof"
    "os"
)

func enableProfiling() {
    // HTTP endpoint for profiling
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()
    // Visit http://localhost:6060/debug/pprof/ for web interface
}

func memoryProfiling() {
    // CPU profiling
    cpuFile, err := os.Create("cpu.prof")
    if err != nil {
        log.Fatal(err)
    }
    defer cpuFile.Close()

    pprof.StartCPUProfile(cpuFile)
    defer pprof.StopCPUProfile()

    // Memory profiling
    memFile, err := os.Create("mem.prof")
    if err != nil {
        log.Fatal(err)
    }
    defer memFile.Close()

    // Your application code here
    doMemoryIntensiveWork()

    // Write memory profile
    runtime.GC() // Get up-to-date statistics
    if err := pprof.WriteHeapProfile(memFile); err != nil {
        log.Fatal(err)
    }
}

func doMemoryIntensiveWork() {
    // Simulate memory-intensive work
    data := make([][]byte, 1000)
    for i := range data {
        data[i] = make([]byte, 1024*1024) // 1MB each
    }
}

// Analyze profiles:
// go tool pprof cpu.prof
// go tool pprof mem.prof
// go tool pprof http://localhost:6060/debug/pprof/heap
```

---

## Practice Questions

**Note**: B¡n s½ làm bài t­p trong th° måc `homework/` sau này nhé!

### Basic Level

**1. Pointer Arithmetic**
Create functions that demonstrate pointer operations:
- Swap two integers using pointers
- Modify a struct through a pointer
- Implement a linked list with pointers

**2. Memory Allocation**
Compare stack vs heap allocation by:
- Creating functions that return local variables
- Measuring allocation performance
- Using escape analysis to understand Go's decisions

### Intermediate Level

**3. Custom Allocator**
Implement a simple memory pool:
```go
type MemoryPool struct {
    pool [][]byte
    size int
}

func (p *MemoryPool) Allocate() []byte
func (p *MemoryPool) Release(data []byte)
```

**4. Memory-Efficient Data Structures**
Implement memory-optimized versions of:
- Dynamic array with controlled growth
- Hash table with efficient memory usage
- LRU cache with memory limits

**5. Garbage Collection Monitoring**
Create a GC monitor that:
- Tracks GC frequency and pause times
- Measures heap growth patterns
- Alerts on memory pressure

### Advanced Level

**6. High-Performance Object Pool**
Design a production-ready object pool:
```go
type ObjectPool[T any] interface {
    Get() *T
    Put(obj *T)
    Size() int
    DrainTo(count int) []*T
}
```
Features:
- Type-safe generics
- Thread-safe operations
- Automatic cleanup of old objects
- Size limits and monitoring

**7. Memory-Mapped File System**
Implement a memory-mapped file interface:
```go
type MMapFile interface {
    Map(offset, length int64) ([]byte, error)
    Unmap(data []byte) error
    Sync() error
    Close() error
}
```

**8. Zero-Copy Network Buffer**
Create a zero-copy buffer system for network operations:
```go
type ZeroCopyBuffer interface {
    WriteFrom(src io.Reader) (int64, error)
    ReadTo(dst io.Writer) (int64, error)
    Slice(start, end int) ZeroCopyBuffer
    Release()
}
```

**9. Custom Garbage Collector Integration**
Implement finalizers and weak references:
```go
type WeakRef[T any] interface {
    Get() *T
    IsAlive() bool
    SetFinalizer(func(*T))
}

type FinalizerManager interface {
    Register(obj interface{}, finalizer func())
    Unregister(obj interface{})
    RunFinalizers()
}
```

**10. Memory Debugging Framework**
Build a comprehensive memory debugging system:
```go
type MemoryTracker interface {
    Track(ptr unsafe.Pointer, size uintptr, allocType string)
    Untrack(ptr unsafe.Pointer)
    GetLeaks() []MemoryLeak
    GetStats() MemoryStats
}

type MemoryLeak struct {
    Pointer   unsafe.Pointer
    Size      uintptr
    AllocType string
    Stack     []uintptr
    Timestamp time.Time
}
```

Features:
- Allocation tracking with stack traces
- Leak detection
- Memory usage visualization
- Integration with pprof

---

**Expected Completion Time**: 4-5 hours for thorough understanding and practice

**Series Complete!** <‰ You now have solid foundation in Go fundamentals. Ready for real-world projects with DDD architecture and REST APIs!