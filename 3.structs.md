# Lesson 3: Structs and Methods

## Theory

### 1. Structs - Go's "Classes"
Unlike Node.js/TypeScript classes, Go structs are simple data containers without inheritance.

```go
// Basic struct definition
type User struct {
    ID       int    `json:"id"`
    Name     string `json:"name"`
    Email    string `json:"email"`
    Age      int    `json:"age"`
    IsActive bool   `json:"is_active"`
}

// Creating struct instances
user1 := User{
    ID:       1,
    Name:     "John Doe",
    Email:    "john@example.com",
    Age:      25,
    IsActive: true,
}

// Short form (order matters)
user2 := User{1, "Jane Doe", "jane@example.com", 30, true}

// Zero value struct
var user3 User // All fields get zero values
```

**vs TypeScript/Node.js:**
```typescript
// TypeScript class
class User {
    constructor(
        public id: number,
        public name: string,
        public email: string,
        public age: number,
        public isActive: boolean
    ) {}
}
```

### 2. Methods - Functions with Receivers
Methods are functions that belong to a type (usually structs).

```go
// Method with value receiver (gets a copy)
func (u User) GetDisplayName() string {
    return fmt.Sprintf("%s (%d)", u.Name, u.Age)
}

// Method with pointer receiver (can modify original)
func (u *User) Activate() {
    u.IsActive = true
}

func (u *User) UpdateEmail(newEmail string) error {
    if !strings.Contains(newEmail, "@") {
        return fmt.Errorf("invalid email format")
    }
    u.Email = newEmail
    return nil
}

// Usage
user := User{ID: 1, Name: "John", Age: 25}
fmt.Println(user.GetDisplayName()) // "John (25)"

user.Activate()
user.UpdateEmail("john.new@example.com")
```

**Key Rule**: Use pointer receivers when you need to modify the struct or avoid copying large structs.

### 3. Struct Embedding (Composition over Inheritance)
Go doesn't have inheritance, but it has composition through embedding.

```go
type Address struct {
    Street  string `json:"street"`
    City    string `json:"city"`
    Country string `json:"country"`
}

type Person struct {
    Name    string  `json:"name"`
    Age     int     `json:"age"`
    Address Address `json:"address"` // Composition
}

// Anonymous embedding (promotes fields/methods)
type Employee struct {
    Person          // Embedded struct
    ID       int    `json:"id"`
    Position string `json:"position"`
    Salary   float64 `json:"salary"`
}

// Can access embedded fields directly
emp := Employee{
    Person: Person{
        Name: "John",
        Age:  30,
        Address: Address{
            Street:  "123 Main St",
            City:    "New York",
            Country: "USA",
        },
    },
    ID:       1001,
    Position: "Developer",
    Salary:   75000,
}

// Direct access to embedded fields
fmt.Println(emp.Name)    // "John" (from embedded Person)
fmt.Println(emp.Age)     // 30
fmt.Println(emp.Salary)  // 75000
```

### 4. JSON Marshaling/Unmarshaling
Structs work seamlessly with JSON (crucial for REST APIs).

```go
import (
    "encoding/json"
    "fmt"
)

type Product struct {
    ID          int     `json:"id"`
    Name        string  `json:"name"`
    Price       float64 `json:"price"`
    InStock     bool    `json:"in_stock"`
    Description string  `json:"description,omitempty"` // Omit if empty
    CreatedAt   string  `json:"created_at"`
}

// Marshal to JSON
product := Product{
    ID:        1,
    Name:      "Laptop",
    Price:     999.99,
    InStock:   true,
    CreatedAt: "2024-01-15T10:30:00Z",
}

jsonData, err := json.Marshal(product)
if err != nil {
    fmt.Println("Error:", err)
    return
}
fmt.Println(string(jsonData))

// Unmarshal from JSON
jsonStr := `{"id":2,"name":"Phone","price":599.99,"in_stock":false}`
var newProduct Product
err = json.Unmarshal([]byte(jsonStr), &newProduct)
if err != nil {
    fmt.Println("Error:", err)
    return
}
fmt.Printf("%+v\n", newProduct)
```

### 5. Constructor Pattern
Go doesn't have constructors, but we use factory functions.

```go
// Constructor function
func NewUser(name, email string, age int) (*User, error) {
    if name == "" {
        return nil, fmt.Errorf("name cannot be empty")
    }
    if !strings.Contains(email, "@") {
        return nil, fmt.Errorf("invalid email format")
    }
    if age < 0 {
        return nil, fmt.Errorf("age cannot be negative")
    }

    return &User{
        Name:     name,
        Email:    email,
        Age:      age,
        IsActive: true,
    }, nil
}

// Usage
user, err := NewUser("John Doe", "john@example.com", 25)
if err != nil {
    fmt.Println("Error creating user:", err)
    return
}
```

---

## Practice Questions

### Basic Level

**1. E-commerce Product Structure**
Create a `Product` struct with fields: ID, Name, Price, Category, InStock. Add a method `GetFormattedPrice()` that returns price with currency symbol ($).

**2. User Profile Methods**
Create a `UserProfile` struct with Name, Email, Age. Add methods:
- `IsAdult()` returns true if age >= 18
- `UpdateAge(newAge int)` updates age if valid (0-120)

### Intermediate Level

**3. Blog System**
Create structs for a blog system:
- `Author` (ID, Name, Email, Bio)
- `Post` (ID, Title, Content, Author, PublishedAt, Tags)
- Add methods: `Post.GetSummary(maxLength int)`, `Post.AddTag(tag string)`, `Author.GetPostCount(posts []Post)`

**4. E-commerce Order System**
```go
type OrderItem struct {
    ProductID int
    Quantity  int
    Price     float64
}

type Order struct {
    ID        string
    UserID    int
    Items     []OrderItem
    Status    string
    CreatedAt time.Time
}
```
Add methods:
- `GetTotalAmount()` calculates total order value
- `AddItem(productID int, quantity int, price float64)`
- `GetItemCount()` returns total number of items

### Advanced Level

**5. Banking System with Validation**
Create a banking system:
```go
type Account struct {
    Number    string
    HolderName string
    Balance   float64
    Type      string // "savings", "checking"
    IsActive  bool
}

type Transaction struct {
    ID        string
    FromAccount string
    ToAccount   string
    Amount    float64
    Type      string // "deposit", "withdrawal", "transfer"
    Timestamp time.Time
    Status    string // "pending", "completed", "failed"
}
```

Implement methods:
- `NewAccount(number, holderName, accountType string)` with validation
- `Deposit(amount float64) error`
- `Withdraw(amount float64) error`
- `Transfer(toAccount *Account, amount float64) (*Transaction, error)`
- Validation rules: Account number format, minimum balance, etc.

**6. Real-world REST API Models**
Create a complete user management system like you'd use in a real project:

```go
type Permission struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
    Code string `json:"code"`
}

type Role struct {
    ID          int          `json:"id"`
    Name        string       `json:"name"`
    Permissions []Permission `json:"permissions"`
}

type User struct {
    ID        int       `json:"id"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    Password  string    `json:"-"` // Never serialize password
    FirstName string    `json:"first_name"`
    LastName  string    `json:"last_name"`
    Roles     []Role    `json:"roles"`
    IsActive  bool      `json:"is_active"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}
```

Implement:
- Constructor with validation
- `GetFullName()` method
- `HasPermission(permissionCode string) bool`
- `AddRole(role Role)` and `RemoveRole(roleID int)`
- `ToJSON()` and `FromJSON(jsonStr string)` methods
- `ValidatePassword(password string) error` (length, complexity)

**7. Microservice Event System**
Design an event-driven system (like you'd use with message queues):

```go
type EventMetadata struct {
    Timestamp   time.Time         `json:"timestamp"`
    Source      string           `json:"source"`
    Version     string           `json:"version"`
    CorrelationID string         `json:"correlation_id"`
    Headers     map[string]string `json:"headers"`
}

type Event struct {
    ID       string          `json:"id"`
    Type     string          `json:"type"`
    Data     interface{}     `json:"data"`
    Metadata EventMetadata   `json:"metadata"`
}

type EventHandler interface {
    Handle(event Event) error
    CanHandle(eventType string) bool
}
```

Implement:
- `NewEvent(eventType string, data interface{})` constructor
- Event validation methods
- JSON marshaling/unmarshaling with custom logic
- Event handler registration system

**8. Advanced Database Entity Pattern**
Create a base entity pattern like you'd use with GORM:

```go
type BaseEntity struct {
    ID        uint      `json:"id" gorm:"primarykey"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    DeletedAt *time.Time `json:"deleted_at,omitempty" gorm:"index"`
}

type ProductCategory struct {
    BaseEntity
    Name        string `json:"name" gorm:"uniqueIndex;not null"`
    Description string `json:"description"`
    ParentID    *uint  `json:"parent_id,omitempty"`
    Parent      *ProductCategory `json:"parent,omitempty" gorm:"foreignKey:ParentID"`
    Children    []ProductCategory `json:"children,omitempty" gorm:"foreignKey:ParentID"`
}
```

Implement:
- Soft delete functionality
- Audit trail methods
- Nested category operations
- Database-ready validation tags
- Repository pattern methods

---

**Expected Completion Time**: 3-4 hours for thorough understanding and practice

**Next Lesson Preview**: Interfaces - Go's powerful duck typing system that enables dependency injection and clean architecture patterns.